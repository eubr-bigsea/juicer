# -*- coding: utf-8 -*-
from textwrap import dedent
from juicer.operation import Operation


class FeatureAssemblerOperation(Operation):
    """FeatureAssemblerOperation.

    Feature Assembler is a transformer that combines a given list of columns
    into a single vector column. It is useful for combining raw features and
    features generated by different feature transformers into a single feature
    vector, in order to train ML models.

    Feature Assembler accepts the following input column types: all numeric
    types, boolean type, and vector type. In each row, the values of the
    input columns will be concatenated into a vector in the specified order.
    """

    def __init__(self, parameters,  named_inputs, named_outputs):
        Operation.__init__(self, parameters,  named_inputs,  named_outputs)

        if 'attributes' not in parameters:
            raise ValueError(
                _("Parameters '{}' must be informed for task {}")
                .format('attributes', self.__class__))

        tmp = 'output_data_{}'.format(self.order)
        self.alias = parameters.get("alias", 'FeatureField')
        self.output = self.named_outputs.get('output data', tmp)

        self.has_code = len(self.named_inputs) == 1
        if self.has_code:
            self.has_import = "from functions.ml.feature_assembler " \
                              "import FeatureAssemblerOperation\n"

    def get_otm_info(self):
        return 'one_stage'

    def generate_code(self):
        """Generate code."""
        code = """
            settings = dict()
            settings['cols'] = {cols}
            settings['alias'] = '{alias}'
            {output} = FeatureAssemblerOperation()
                            .transform({input}, settings, numFrag)
            """.format(output=self.output, alias=self.alias,
                       input=self.named_inputs['input data'],
                       cols=self.parameters['attributes'])

        return dedent(code)

    def generate_code_otm_pre(self):
        """Generate code for optimization task."""
        code = """
        settings = dict()
        settings['cols'] = {cols}
        settings['alias'] = '{alias}'
        conf.append(FeatureAssemblerOperation().preprocessing(settings))
        """.format(alias=self.alias, cols=self.parameters['attributes'])
        return code

    def generate_code_otm(self):
        """Generate code."""
        code = """
        {output} = FeatureAssemblerOperation()
                        .transform_serial({input}, conf_X)
        """.format(output=self.output,
                   input=self.named_inputs['input data'])
        return dedent(code)


class FeatureIndexerOperation(Operation):
    """FeatureIndexerOperation.

    REVIEW: 2017-10-20
    OK - Juicer / Tahiti ???????????? / implementation

    Note:   Adicionar um pre valor no alias
    """

    def __init__(self, parameters,  named_inputs, named_outputs):
        Operation.__init__(self, parameters,  named_inputs,  named_outputs)

        if 'attributes' not in parameters:
            raise ValueError(
                _("Parameters '{}' must be informed for task {}")
                .format('attributes', self.__class__))
        elif 'alias' not in parameters:
            raise ValueError(
                _("Parameters '{}' must be informed for task {}")
                .format('alias', self.__class__))

        elif 'type' not in parameters:
            raise ValueError(
                _("Parameters '{}' must be informed for task {}")
                .format('type', self.__class__))

        tmp = 'output_data_{}'.format(self.order)
        self.output = self.named_outputs.get('output data', tmp)
        self.alias = parameters.get("alias", 'FeatureIndexed')
        self.has_code = len(self.named_inputs) == 1
        self.mode = False
        if self.has_code:
            self.has_import = "from functions.ml.feature_indexer " \
                              "import FeatureIndexerOperation\n"

    def get_otm_info(self):
        if not self.mode:
            return 'many_stages'
        else:
            return 'many_stages' #'one_stage'

    def generate_code(self):
        """Generate Code."""
        code = """
            settings = dict()
            settings['inputCol'] = {columns}
            settings['outputCol'] = '{alias}'
            settings['IndexToString'] = {mode} #Currently, only String to Index
            {out}, mapper = FeatureIndexerOperation({input}, settings, numFrag)
            """.format(out=self.output, alias=self.alias,
                       input=self.named_inputs['input data'],
                       columns=self.parameters['attributes'],
                       mode=self.mode)

        return dedent(code)
